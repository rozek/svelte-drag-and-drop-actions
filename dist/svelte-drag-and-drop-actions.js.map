{"version":3,"file":"svelte-drag-and-drop-actions.js","sources":["../src/svelte-drag-and-drop-actions.ts"],"sourcesContent":["//----------------------------------------------------------------------------//\n//                        Svelte Drag-and-Drop Actions                        //\n//----------------------------------------------------------------------------//\n\n  import {\n    global, throwError,\n    ValueIsNumber, ValueIsFiniteNumber, ValueIsString, ValueIsNonEmptyString,\n    ValueIsFunction, ValueIsPlainObject, ValueIsOneOf,\n    allowedFiniteNumber, allowedIntegerInRange, allowedOrdinal,\n    allowedString, allowedNonEmptyString,\n    allowPlainObject, allowedPlainObject,\n    allowListSatisfying, allowedFunction,\n    ObjectIsNotEmpty, quoted, constrained\n  } from 'javascript-interface-library'\n\n  import Conversion from 'svelte-coordinate-conversion'\n\n/**** never ever trust module loading if you REALLY need a singleton! ****/\n// finding multiple existing singletons if you actually trust them is so hard!\n\n  type ContextType = extendedDragAndDropSupport & SupportForHoldingAndPanning\n  const Context:ContextType = (            // make this package a REAL singleton\n    '__DragAndDropActions' in global\n    ? global.__DragAndDropActions\n    : global.__DragAndDropActions = {}\n  )\n\n//-------------------------------------------------------------------------------\n//--             use:asDraggable={options} - \"drag\" without \"drop\"             --\n//-------------------------------------------------------------------------------\n\n  export type PositionReference = (\n    'parent' | 'body' | string | HTMLElement | SVGElement // | MathMLElement\n  )\n\n  export type Position = { x:number, y:number }\n\n  export type DragDummy = (\n    string | HTMLElement | SVGElement | // MathMLElement |\n    ((DraggableExtras:any, Element:HTMLElement|SVGElement) => HTMLElement|SVGElement) |\n    'standard' | 'none'\n  ) | null | undefined\n\n  type DraggableOptions = {\n    Extras?:any,\n    relativeTo?:PositionReference, onlyFrom?:string, neverFrom?:string,\n    Dummy?:DragDummy, DummyOffsetX?:number, DummyOffsetY?:number,\n    minX?:number, minY?:number, maxX?:number, maxY?:number,\n    Pannable?:string|HTMLElement|SVGElement,\n    PanSensorWidth?:number, PanSensorHeight?:number, PanSpeed?:number,\n    onDragStart?:Position | ((DraggableExtras:any) => Position),\n    onDragMove?: (x:number,y:number, dx:number,dy:number, DraggableExtras:any) => void,\n    onDragEnd?:  (x:number,y:number, dx:number,dy:number, DraggableExtras:any) => void,\n  }\n\n/**** parsedDraggableOptions ****/\n\n  function parsedDraggableOptions (Options:any):DraggableOptions {\n    Options = allowedPlainObject('drag options',Options) || {}\n\n    let Extras:any, relativeTo:PositionReference\n    let onlyFrom:string|undefined, neverFrom:string|undefined\n    let Dummy:DragDummy, DummyOffsetX:number, DummyOffsetY:number\n    let minX:number, minY:number, maxX:number, maxY:number\n    let Pannable:string|HTMLElement|SVGElement|undefined\n    let PanSensorWidth:number, PanSensorHeight:number, PanSpeed:number\n    let onDragStart:Function, onDragMove:Function, onDragEnd:Function, onDragCancel:Function\n\n    Extras = Options.Extras\n\n    switch (true) {\n      case (Options.relativeTo == null):\n        relativeTo = 'parent'; break\n      case (Options.relativeTo === 'parent'):\n      case (Options.relativeTo === 'body'):\n      case ValueIsNonEmptyString(Options.relativeTo):\n      case (Options.relativeTo instanceof HTMLElement):\n      case (Options.relativeTo instanceof SVGElement):\n//    case (Options.relativeTo instanceof MathMLElement):\n        relativeTo = Options.relativeTo as PositionReference; break\n      default: throwError(\n        'InvalidArgument: invalid position reference given'\n      )\n    }\n\n    onlyFrom  = allowedNonEmptyString ('\"onlyFrom\" CSS selector',Options.onlyFrom)\n    neverFrom = allowedNonEmptyString('\"neverFrom\" CSS selector',Options.neverFrom)\n\n    switch (true) {\n      case (Options.Dummy == null):\n        Dummy = undefined; break\n      case (Options.Dummy === 'standard'):\n      case (Options.Dummy === 'none'):\n      case ValueIsNonEmptyString(Options.Dummy):\n      case (Options.Dummy instanceof HTMLElement):\n      case (Options.Dummy instanceof SVGElement):\n//    case (Options.Dummy instanceof MathMLElement):\n      case ValueIsFunction(Options.Dummy):\n        Dummy = Options.Dummy as DragDummy; break\n      default: throwError(\n        'InvalidArgument: invalid drag dummy specification given'\n      )\n    }\n\n    DummyOffsetX = allowedFiniteNumber('dummy x offset',Options.DummyOffsetX)\n    DummyOffsetY = allowedFiniteNumber('dummy y offset',Options.DummyOffsetY)\n\n    minX = allowedFiniteNumber('min. x position',Options.minX)\n      if (minX == null) { minX = -Infinity }\n    minY = allowedFiniteNumber('min. y position',Options.minY)\n      if (minY == null) { minY = -Infinity }\n    maxX = allowedFiniteNumber('max. x position',Options.maxX)\n      if (maxX == null) { maxX = Infinity }\n    maxY = allowedFiniteNumber('max. y position',Options.maxY)\n      if (maxY == null) { maxY = Infinity }\n\n    switch (true) {\n      case (Options.Pannable == null):\n        Pannable = undefined; break\n      case ValueIsNonEmptyString(Options.Pannable):\n      case (Options.Pannable instanceof HTMLElement):\n      case (Options.Pannable instanceof SVGElement):\n//    case (Options.Pannable instanceof MathMLElement):\n        Pannable = Options.Pannable; break\n      default: throwError(\n        'InvalidArgument: invalid \"Pannable\" specification given'\n      )\n    }\n\n    PanSensorWidth  = allowedOrdinal ('panning sensor width',Options.PanSensorWidth)\n      if (PanSensorWidth  == null) { PanSensorWidth = 20 }\n    PanSensorHeight = allowedOrdinal('panning sensor height',Options.PanSensorHeight)\n      if (PanSensorHeight == null) { PanSensorHeight = 20 }\n    PanSpeed        = allowedOrdinal        ('panning speed',Options.PanSpeed)\n      if (PanSpeed == null) { PanSpeed = 10 }\n\n    if (ValueIsPosition(Options.onDragStart)) {\n      let { x,y } = Options.onDragStart as Position\n      onDragStart = () => ({x,y})\n    } else {\n      onDragStart = allowedFunction('\"onDragStart\" handler', Options.onDragStart)\n    }\n\n    onDragMove = allowedFunction('\"onDragMove\" handler', Options.onDragMove)\n    onDragEnd  = allowedFunction('\"onDragEnd\" handler',  Options.onDragEnd)\n\n    return {\n      Extras, relativeTo, onlyFrom,neverFrom, Dummy, DummyOffsetX,DummyOffsetY,\n      minX,minY, maxX,maxY,\n      Pannable, PanSensorWidth,PanSensorHeight, PanSpeed,\n// @ts-ignore we cannot validate given functions any further\n      onDragStart, onDragMove, onDragEnd, onDragCancel\n    }\n  }\n\n/**** use:asDraggable={options} ****/\n\n  export function asDraggable (\n    Element:HTMLElement|SVGElement, Options:DraggableOptions\n  ) {\n    let isDragged:boolean\n    let currentDraggableOptions:DraggableOptions\n\n    let PositionReference:Element         // element with user coordinate system\n    let ReferenceDeltaX:number, ReferenceDeltaY:number  // mouse -> user coord.s\n    let PositioningWasDelayed:boolean // workaround for prob. with \"drag\" events\n    let DragImage:Element | undefined\n    let initialPosition:Position                    // given in user coordinates\n    let lastPosition:   Position                                         // dto.\n\n    isDragged = false\n\n    currentDraggableOptions = parsedDraggableOptions(Options)\n\n  /**** startDragging ****/\n\n    function startDragging (originalEvent:DragEvent) {\n      let Options = currentDraggableOptions\n\n      if (fromForbiddenElement(Element,Options,originalEvent)) {\n        originalEvent.stopPropagation()\n        originalEvent.preventDefault()\n        return false\n      }\n\n      PositionReference = PositionReferenceFor(Element,Options)\n\n      let relativePosition = Conversion.fromDocumentTo(\n        'local', { left:originalEvent.pageX, top:originalEvent.pageY }, PositionReference\n      )                                         // relative to reference element\n\n      ReferenceDeltaX = ReferenceDeltaY = 0; initialPosition = { x:0,y:0 }\n      if (Options.onDragStart == null) {\n        initialPosition = { x:0,y:0 }               // given in user coordinates\n      } else {\n        try {\n          let StartPosition = (Options.onDragStart as Function)(Options.Extras)\n          if (ValueIsPlainObject(StartPosition)) {\n            let x = allowedFiniteNumber('x start position',StartPosition.x)\n            let y = allowedFiniteNumber('y start position',StartPosition.y)\n\n            ReferenceDeltaX = x - relativePosition.left\n            ReferenceDeltaY = y - relativePosition.top\n\n            x = constrained(x, Options.minX,Options.maxX)\n            y = constrained(y, Options.minY,Options.maxY)\n\n            initialPosition = { x,y }               // given in user coordinates\n          }\n        } catch (Signal) {\n          console.error('\"onDragStart\" handler failed',Signal)\n        }\n      }\n\n      lastPosition = initialPosition\n\n      PositioningWasDelayed = false                    // initializes workaround\n\n      if (Options.Dummy == null) {\n        Options.Dummy = 'none'      // this is the default for \"use.asDraggable\"\n      }\n\n      DragImage = DragImageFor(Element,Options)\n      if ((DragImage != null) && (originalEvent.dataTransfer != null)) {\n        let OffsetX = Options.DummyOffsetX as number\n        let OffsetY = Options.DummyOffsetY as number\n\n        if ((OffsetX == null) || (OffsetY == null)) {\n          let PositionInDraggable = Conversion.fromDocumentTo(\n            'local', { left:originalEvent.pageX, top:originalEvent.pageY }, Element\n          )\n\n          if (OffsetX == null) { OffsetX = PositionInDraggable.left }\n          if (OffsetY == null) { OffsetY = PositionInDraggable.top }\n        }\n\n        switch (true) {\n          case (Options.Dummy === 'none'):\n            originalEvent.dataTransfer.setDragImage(DragImage,0,0)\n            setTimeout(() => { // remove element after browser took its snapshot\n              document.body.removeChild(DragImage as HTMLElement)\n            },0)\n            break\n          case ValueIsString(Options.Dummy):\n            originalEvent.dataTransfer.setDragImage(DragImage, OffsetX,OffsetY)\n            setTimeout(() => { // remove element after browser took its snapshot\n              document.body.removeChild(\n                (DragImage as HTMLElement).parentElement as HTMLElement\n              )\n            },0)\n            break\n          default:\n            originalEvent.dataTransfer.setDragImage(DragImage, OffsetX,OffsetY)\n        }\n      }\n\n      if (originalEvent.dataTransfer != null) {\n        originalEvent.dataTransfer.effectAllowed = 'none'\n      }\n\n      isDragged = true\n      setTimeout(() => Element.classList.add('dragged'), 0)\n\n      originalEvent.stopPropagation()\n    }\n\n  /**** continueDragging ****/\n\n    function continueDragging (originalEvent:DragEvent) {\n      if (! isDragged) { return false }\n\n      let Options = currentDraggableOptions\n\n      if (\n        (originalEvent.screenX === 0) && (originalEvent.screenY === 0) &&\n        ! PositioningWasDelayed\n      ) {\n        PositioningWasDelayed = true // last \"drag\" event contains wrong coord.s\n      } else {\n        PositioningWasDelayed = false\n\n        performPanningFor(\n          'draggable',\n          Element, Options, originalEvent.pageX,originalEvent.pageY\n        )\n\n        let relativePosition = Conversion.fromDocumentTo(\n          'local', { left:originalEvent.pageX, top:originalEvent.pageY }, PositionReference\n        )                                       // relative to reference element\n\n        let x  = relativePosition.left + ReferenceDeltaX  // in user coordinates\n        let y  = relativePosition.top  + ReferenceDeltaY\n\n        x = constrained(x, Options.minX,Options.maxX)\n        y = constrained(y, Options.minY,Options.maxY)\n\n        let dx = x - lastPosition.x         // calculated AFTER constraining x,y\n        let dy = y - lastPosition.y                                      // dto.\n\n        lastPosition = { x,y }\n\n        invokeHandler('onDragMove', Options, x,y, dx,dy, Options.Extras)\n      }\n\n      originalEvent.stopPropagation()\n    }\n\n  /**** finishDragging ****/\n\n    function finishDragging (originalEvent:DragEvent) {\n      if (! isDragged) { return false }\n\n//    continueDragging(originalEvent)           // NO! positions might be wrong!\n\n      let Options = currentDraggableOptions\n\n      if (Options.onDragEnd != null) {\n        let x = constrained(lastPosition.x, Options.minX,Options.maxX)\n        let y = constrained(lastPosition.y, Options.minY,Options.maxY)\n\n        let dx = x - lastPosition.x\n        let dy = y - lastPosition.y\n\n        invokeHandler('onDragEnd', Options, x,y, dx,dy, Options.Extras)\n      }\n\n      isDragged = false\n      Element.classList.remove('dragged')\n\n      originalEvent.stopPropagation()\n    }\n\n  /**** updateDraggableOptions ****/\n\n    function updateDraggableOptions (Options:any):void {\n      Options = parsedDraggableOptions(Options)\n\n      if (\n        (currentDraggableOptions.Extras == null) && (Options.Extras != null)\n      ) {\n        currentDraggableOptions.Extras = Options.Extras\n      }           // Extras may be set with delay, but remain constant afterwards\n\n      currentDraggableOptions.Dummy = (\n        Options.Dummy || currentDraggableOptions.Dummy\n      )\n\n      currentDraggableOptions.minX = Options.minX\n      currentDraggableOptions.minY = Options.minY\n      currentDraggableOptions.maxX = Options.maxX\n      currentDraggableOptions.maxY = Options.maxY\n\n      currentDraggableOptions.Pannable        = Options.Pannable\n      currentDraggableOptions.PanSensorWidth  = Options.PanSensorWidth\n      currentDraggableOptions.PanSensorHeight = Options.PanSensorHeight\n      currentDraggableOptions.PanSpeed        = Options.PanSpeed\n\n      currentDraggableOptions.onDragStart = (\n        Options.onDragStart || currentDraggableOptions.onDragStart\n      )           // may be used to update initial position for subsequent drags\n    }\n\n    Element.setAttribute('draggable','true')\n\n// @ts-ignore we know that the passed event is a DragEvent\n    Element.addEventListener('dragstart', startDragging)\n// @ts-ignore we know that the passed event is a DragEvent\n    Element.addEventListener('drag',      continueDragging)\n// @ts-ignore we know that the passed event is a DragEvent\n    Element.addEventListener('dragend',   finishDragging)\n\n    return { update:updateDraggableOptions }\n  }\n\n/**** fromForbiddenElement ****/\n\n  function fromForbiddenElement (\n    Element:HTMLElement|SVGElement, Options:DraggableOptions,\n    originalEvent:DragEvent\n  ):boolean {\n    if ((Options.onlyFrom != null) || (Options.neverFrom != null)) {\n      let x = originalEvent.clientX\n      let y = originalEvent.clientY\n\n      let touchedElement = document.elementFromPoint(x,y) as HTMLElement\n\n//    elementFromPoint considers elements with \"pointer-events\" <> \"none\" only\n//    but sometimes, \"pointer-events:none\" is needed for proper operation\n\n      touchedElement = innerElementOf(touchedElement, x,y)\n\n      if (Options.onlyFrom != null) {\n        let fromElement = touchedElement.closest(Options.onlyFrom as string)\n        if ((Element !== fromElement) && ! Element.contains(fromElement)) {\n          return true\n        }\n      }\n\n      if (Options.neverFrom != null) {\n        let fromElement = touchedElement.closest(Options.neverFrom as string)\n        if ((Element === fromElement) || Element.contains(fromElement)) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n/**** innerElementOf ****/\n\n  function innerElementOf (Candidate:HTMLElement, x:number,y:number):HTMLElement {\n    let innerElements = Candidate.children\n    for (let i = 0, l = innerElements.length; i < l; i++) {\n      let innerElement = innerElements[i] as HTMLElement\n\n      let Position = Conversion.fromLocalTo(\n        'viewport', { left:0, top:0 }, innerElement\n      )\n      if ((x < Position.left) || (y < Position.top)) { continue }\n\n      if (x > Position.left+innerElement.offsetWidth-1) { continue }\n      if (y > Position.top+innerElement.offsetHeight-1) { continue }\n\n      return innerElementOf(innerElement, x,y)\n    }\n\n    return Candidate               // this is the innermost element at (x,y)\n  }\n\n/**** extended Drag-and-Drop Support ****/\n\n  type extendedDragAndDropSupport = {\n    currentDroppableExtras:any,        // extras for currently dragged droppable\n    currentDropZoneExtras:any,         // extras for currently hovered drop zone\n    currentDropZoneElement:Element|undefined,                 // dto. as Element\n\n    DroppableWasDropped:boolean,        // indicates a successful drop operation\n    currentDropZonePosition:Position|undefined, // position relative to DropZone\n    currentDropOperation:DropOperation|undefined,       // actual drop operation\n    currentTypeTransferred:string|undefined,  // actual type of transferred data\n    currentDataTransferred:any,                       // actual data transferred\n  }\n\n/**** Support for Holding and Panning ****/\n\n  type SupportForHoldingAndPanning = {\n    HoldPosition?:Position,               // current position to compare against\n    HoldTimer?:any,\n    HoldWasTriggeredForElement?:HTMLElement | SVGElement,\n\n    DropZonePanning?:boolean\n  }                                           // because we trigger it once only\n\n//-------------------------------------------------------------------------------\n//--               use:asDroppable={options} - \"drag\" and \"drop\"               --\n//-------------------------------------------------------------------------------\n\n  export const DropOperations = [ 'copy', 'move', 'link' ]\n  export type  DropOperation  = typeof DropOperations[number]\n\n  export type DataOfferSet = { [Type:string]:string }\n\n  type DroppableOptions = DraggableOptions & {\n    Operations?:string,// consisting of 'copy', 'move', 'link' (blank-separated)\n    DataToOffer?:DataOfferSet,\n    onDropZoneEnter?: (x:number,y:number, DropZoneExtras:any, DroppableExtras:any) => void,\n    onDropZoneHover?: (x:number,y:number, DropZoneExtras:any, DroppableExtras:any) => void,\n    onDropZoneLeave?: (DropZoneExtras:any, DroppableExtras:any) => void,\n    onDropped?:       (x:number,y:number, Operation:DropOperation,\n                        TypeTransferred:string, DataTransferred:any,\n                        DropZoneExtras:any, DroppableExtras:any) => void,\n  }\n\n/**** parsedDroppableOptions ****/\n\n  function parsedDroppableOptions (Options:any):DroppableOptions {\n    Options = allowedPlainObject('drop options',Options) || {}\n\n    let Operations:string, DataToOffer:DataOfferSet\n    let onDropZoneEnter:Function, onDropZoneHover:Function, onDropZoneLeave:Function\n    let onDropped:Function\n\n    Operations  = parsedOperations('list of allowed operations',Options.Operations,'copy')\n    DataToOffer = Object.assign(\n      {}, allowedPlainObject('data to be offered',Options.DataToOffer)\n    )\n    if ('none' in DataToOffer) throwError(\n      'InvalidArgument: \"none\" is not a valid data type'\n    )\n\n    onDropZoneEnter = allowedFunction('\"onDropZoneEnter\" handler',Options.onDropZoneEnter)\n    onDropZoneHover = allowedFunction('\"onDropZoneHover\" handler',Options.onDropZoneHover)\n    onDropZoneLeave = allowedFunction('\"onDropZoneLeave\" handler',Options.onDropZoneLeave)\n    onDropped       = allowedFunction('\"onDropped\" handler',      Options.onDropped)\n\n    return {\n      Operations, DataToOffer,\n// @ts-ignore we cannot validate given functions any further\n      onDropZoneEnter, onDropZoneHover, onDropZoneLeave, onDropped\n    }\n  }\n\n/**** use:asDroppable={options} ****/\n\n  export function asDroppable (\n    Element:HTMLElement|SVGElement, Options:DroppableOptions\n  ) {\n    let isDragged:boolean\n    let currentDraggableOptions:DraggableOptions\n    let currentDroppableOptions:DroppableOptions\n\n    let PositionReference:Element         // element with user coordinate system\n    let ReferenceDeltaX:number, ReferenceDeltaY:number  // mouse -> user coord.s\n    let PositioningWasDelayed:boolean // workaround for prob. with \"drag\" events\n    let DragImage:Element | undefined\n    let initialPosition:Position                    // given in user coordinates\n    let lastPosition:   Position                                         // dto.\n\n    let lastDropZoneElement:HTMLElement|SVGElement|undefined\n    let lastDropZoneExtras:any\n\n    isDragged = false\n\n    currentDraggableOptions = parsedDraggableOptions(Options)\n    currentDroppableOptions = parsedDroppableOptions(Options)\n\n  /**** startDragging ****/\n\n    function startDragging (originalEvent:DragEvent) {\n      let Options = Object.assign(\n        {}, currentDraggableOptions, currentDroppableOptions\n      )\n\n      if (fromForbiddenElement(Element,Options,originalEvent)) {\n        originalEvent.stopPropagation()\n        originalEvent.preventDefault()\n        return false\n      }\n\n      PositionReference = PositionReferenceFor(Element,Options)\n\n      let relativePosition = Conversion.fromDocumentTo(\n        'local', { left:originalEvent.pageX, top:originalEvent.pageY }, PositionReference\n      )                                         // relative to reference element\n\n      ReferenceDeltaX = ReferenceDeltaY = 0; initialPosition = { x:0,y:0 }\n      if (Options.onDragStart == null) {\n        initialPosition = { x:0,y:0 }               // given in user coordinates\n      } else {\n        try {\n          let StartPosition = (Options.onDragStart as Function)(Options.Extras)\n          if (ValueIsPlainObject(StartPosition)) {\n            let x = allowedFiniteNumber('x start position',StartPosition.x)\n            let y = allowedFiniteNumber('y start position',StartPosition.y)\n\n            ReferenceDeltaX = x - relativePosition.left\n            ReferenceDeltaY = y - relativePosition.top\n\n            x = constrained(x, Options.minX,Options.maxX)\n            y = constrained(y, Options.minY,Options.maxY)\n\n            initialPosition = { x,y }               // given in user coordinates\n          }\n        } catch (Signal) {\n          console.error('\"onDragStart\" handler failed',Signal)\n        }\n      }\n\n      lastPosition        = initialPosition\n      lastDropZoneElement = undefined\n      lastDropZoneExtras  = undefined\n\n      PositioningWasDelayed = false                    // initializes workaround\n\n      if (Options.Dummy == null) {\n        Options.Dummy = 'standard'  // this is the default for \"use.asDroppable\"\n      }\n\n      DragImage = DragImageFor(Element,Options)\n      if ((DragImage != null) && (originalEvent.dataTransfer != null)) {\n        let OffsetX = Options.DummyOffsetX as number\n        let OffsetY = Options.DummyOffsetY as number\n\n        if ((OffsetX == null) || (OffsetY == null)) {\n          let PositionInDraggable = Conversion.fromDocumentTo(\n            'local', { left:originalEvent.pageX, top:originalEvent.pageY }, Element\n          )\n\n          if (OffsetX == null) { OffsetX = PositionInDraggable.left }\n          if (OffsetY == null) { OffsetY = PositionInDraggable.top }\n        }\n\n        switch (true) {\n          case (Options.Dummy === 'none'):\n            originalEvent.dataTransfer.setDragImage(DragImage,0,0)\n            setTimeout(() => { // remove element after browser took its snapshot\n              document.body.removeChild(DragImage as HTMLElement)\n            },0)\n            break\n          case ValueIsString(Options.Dummy):\n            originalEvent.dataTransfer.setDragImage(DragImage, OffsetX,OffsetY)\n            setTimeout(() => { // remove element after browser took its snapshot\n              document.body.removeChild(\n                (DragImage as HTMLElement).parentElement as HTMLElement\n              )\n            },0)\n            break\n          default:\n            originalEvent.dataTransfer.setDragImage(DragImage, OffsetX,OffsetY)\n        }\n      }\n\n      if (originalEvent.dataTransfer != null) {\n        let allowedEffects = allowedEffectsFrom(Options.Operations as string)\n        originalEvent.dataTransfer.effectAllowed = allowedEffects\n\n        if (ObjectIsNotEmpty(Options.DataToOffer)) {\n          for (let Type in Options.DataToOffer) {\n            if (Options.DataToOffer.hasOwnProperty(Type)) {\n              originalEvent.dataTransfer.setData(\n                Type, Options.DataToOffer[Type]\n              )\n            }\n          }\n        }\n      }\n\n      Context.currentDroppableExtras  = Options.Extras\n      Context.currentDropZoneExtras   = undefined\n      Context.currentDropZonePosition = undefined\n      Context.currentDropZoneElement  = undefined\n\n      Context.DroppableWasDropped     = false\n      Context.currentDropOperation    = undefined\n      Context.currentTypeTransferred  = undefined\n      Context.currentDataTransferred  = undefined\n\n      isDragged = true\n      setTimeout(() => Element.classList.add('dragged'), 0)\n\n      originalEvent.stopPropagation()\n    }\n\n  /**** continueDragging ****/\n\n    function continueDragging (originalEvent:DragEvent) {\n      if (! isDragged) { return false }\n\n      let Options = Object.assign(\n        {}, currentDraggableOptions, currentDroppableOptions\n      )\n\n      if (\n        (originalEvent.screenX === 0) && (originalEvent.screenY === 0) &&\n        ! PositioningWasDelayed\n      ) {\n        PositioningWasDelayed = true // last \"drag\" event contains wrong coord.s\n      } else {\n        PositioningWasDelayed = false\n\n        performPanningFor(\n          'draggable',\n          Element, Options, originalEvent.pageX,originalEvent.pageY\n        )\n\n        let relativePosition = Conversion.fromDocumentTo(\n          'local', { left:originalEvent.pageX, top:originalEvent.pageY }, PositionReference\n        )                                       // relative to reference element\n\n        let x  = relativePosition.left + ReferenceDeltaX  // in user coordinates\n        let y  = relativePosition.top  + ReferenceDeltaY\n\n        x = constrained(x, Options.minX,Options.maxX)\n        y = constrained(y, Options.minY,Options.maxY)\n\n        let dx = x - lastPosition.x         // calculated AFTER constraining x,y\n        let dy = y - lastPosition.y                                      // dto.\n\n        lastPosition = { x,y }\n\n        invokeHandler('onDragMove', Options, x,y, dx,dy, Options.Extras)\n      }\n\n      if (Context.currentDropZoneElement === lastDropZoneElement) {\n        if (Context.currentDropZoneElement != null) {\n          invokeHandler(\n            'onDropZoneHover', Options,\n            (Context.currentDropZonePosition as Position).x,(Context.currentDropZonePosition as Position).y,\n            Context.currentDropZoneExtras, Options.Extras\n          )\n        }\n      } else {\n        if (Context.currentDropZoneElement == null) {\n          Element.classList.remove('droppable')\n          invokeHandler('onDropZoneLeave', Options, lastDropZoneExtras, Options.Extras)\n        } else {\n          Element.classList.add('droppable')\n          invokeHandler(\n            'onDropZoneEnter', Options,\n            (Context.currentDropZonePosition as Position).x,(Context.currentDropZonePosition as Position).y,\n            lastDropZoneExtras, Options.Extras\n          )\n        }\n\n        lastDropZoneElement = Context.currentDropZoneElement as HTMLElement\n        lastDropZoneExtras  = Context.currentDropZoneExtras\n      }\n\n      originalEvent.stopPropagation()\n    }\n\n  /**** finishDragging ****/\n\n    function finishDragging (originalEvent:DragEvent) {\n      if (! isDragged) { return false }\n\n//    continueDragging(originalEvent)           // NO! positions might be wrong!\n\n      let Options = Object.assign(\n        {}, currentDraggableOptions, currentDroppableOptions\n      )\n\n      if (Context.DroppableWasDropped) {\n        invokeHandler(\n          'onDropped', Options,\n          (Context.currentDropZonePosition as Position).x,(Context.currentDropZonePosition as Position).y,\n          Context.currentDropOperation, Context.currentTypeTransferred, Context.currentDataTransferred,\n          Context.currentDropZoneExtras, Options.Extras\n        )\n\n        Context.currentDropZoneExtras   = undefined\n        Context.currentDropZonePosition = undefined\n        Context.currentDropZoneElement  = undefined\n\n        Context.DroppableWasDropped     = false\n        Context.currentDropOperation    = undefined\n        Context.currentTypeTransferred  = undefined\n        Context.currentDataTransferred  = undefined\n      }\n\n      if (Options.onDragEnd != null) {\n        let x = constrained(lastPosition.x, Options.minX,Options.maxX)\n        let y = constrained(lastPosition.y, Options.minY,Options.maxY)\n\n        let dx = x - lastPosition.x\n        let dy = y - lastPosition.y\n\n        invokeHandler('onDragEnd', Options, x,y, dx,dy, Options.Extras)\n      }\n\n      Context.currentDroppableExtras = undefined\n\n      isDragged = false\n      Element.classList.remove('dragged','droppable')\n\n      originalEvent.stopPropagation()\n    }\n\n  /**** updateDraggableOptions ****/\n\n    function updateDraggableOptions (Options:any):void {\n      Options = parsedDraggableOptions(Options)\n\n      if (\n        (currentDraggableOptions.Extras == null) && (Options.Extras != null)\n      ) {\n        currentDraggableOptions.Extras = Options.Extras\n      }           // Extras may be set with delay, but remain constant afterwards\n\n      currentDraggableOptions.Dummy = (\n        Options.Dummy || currentDraggableOptions.Dummy\n      )\n\n      currentDraggableOptions.minX = Options.minX\n      currentDraggableOptions.minY = Options.minY\n      currentDraggableOptions.maxX = Options.maxX\n      currentDraggableOptions.maxY = Options.maxY\n\n      currentDraggableOptions.Pannable        = Options.Pannable\n      currentDraggableOptions.PanSensorWidth  = Options.PanSensorWidth\n      currentDraggableOptions.PanSensorHeight = Options.PanSensorHeight\n      currentDraggableOptions.PanSpeed        = Options.PanSpeed\n\n      currentDraggableOptions.onDragStart = (\n        Options.onDragStart || currentDraggableOptions.onDragStart\n      )           // may be used to update initial position for subsequent drags\n    }\n\n  /**** updateDroppableOptions ****/\n\n    function updateDroppableOptions (Options:any):void {\n      Options = parsedDroppableOptions(Options)\n\n      currentDroppableOptions.Operations  = Options.Operations\n      currentDroppableOptions.DataToOffer = Options.DataToOffer\n    }\n\n    Element.setAttribute('draggable','true')\n\n// @ts-ignore we know that the passed event is a DragEvent\n    Element.addEventListener('dragstart', startDragging)\n// @ts-ignore we know that the passed event is a DragEvent\n    Element.addEventListener('drag',      continueDragging)\n// @ts-ignore we know that the passed event is a DragEvent\n    Element.addEventListener('dragend',   finishDragging)\n\n    return {\n      update:(Options:any) => {\n        updateDraggableOptions(Options)\n        updateDroppableOptions(Options)\n      }\n    }\n  }\n\n//-------------------------------------------------------------------------------\n//--                 use:asDropZone={options} - for drop zones                 --\n//-------------------------------------------------------------------------------\n\n  export type TypeAcceptanceSet = { [Type:string]:string }\n                   // values consist of 'copy', 'move', 'link' (blank-separated)\n  type DropZoneOptions = {\n    Extras?:any,\n    TypesToAccept?:TypeAcceptanceSet,\n    HoldDelay?:number,\n    Pannable?:string|'this'|HTMLElement|SVGElement,\n    PanSensorWidth?:number, PanSensorHeight?:number, PanSpeed?:number,\n    onDroppableEnter?:(x:number,y:number, Operation:DropOperation, offeredTypeList:string[],\n                        DroppableExtras:any, DropZoneExtras:any) => boolean|undefined,\n    onDroppableMove?: (x:number,y:number, Operation:DropOperation, offeredTypeList:string[],\n                        DroppableExtras:any, DropZoneExtras:any) => boolean|undefined,\n    onDroppableHold?: (x:number,y:number, DroppableExtras:any, DropZoneExtras:any) => void,\n    onDroppableLeave?:(DroppableExtras:any, DropZoneExtras:any) => void,\n    onDrop?:          (x:number,y:number, Operation:DropOperation, DataOffered:any,\n                        DroppableExtras:any, DropZoneExtras:any) => string | undefined,\n  }\n\n/**** parsedDropZoneOptions ****/\n\n  function parsedDropZoneOptions (Options:any):DropZoneOptions {\n    Options = allowedPlainObject('drop zone options',Options) || {}\n\n    let Extras:any, TypesToAccept:TypeAcceptanceSet, HoldDelay:number\n    let Pannable:string|'this'|HTMLElement|SVGElement|undefined\n    let PanSensorWidth:number, PanSensorHeight:number, PanSpeed:number\n    let onDroppableEnter:Function, onDroppableMove:Function, onDroppableLeave:Function\n    let onDroppableHold:Function, onDroppableRelease:Function, onDrop:Function\n\n    Extras = Options.Extras\n\n    allowPlainObject('data types to be accepted',Options.TypesToAccept)\n    TypesToAccept = Object.create(null)\n      if ((Options.TypesToAccept != null) && ('none' in Options.TypesToAccept)) throwError(\n        'InvalidArgument: \"none\" is not a valid data type'\n      )\n\n      for (let Type in Options.TypesToAccept) {\n        if (Options.TypesToAccept.hasOwnProperty(Type)) {\n          TypesToAccept[Type] = parsedOperations(\n            'list of accepted operations for type ' + quoted(Type),\n            Options.TypesToAccept[Type]\n          )\n        }\n      }\n    HoldDelay = allowedIntegerInRange('min. time to hold',Options.HoldDelay, 0) as number\n\n    switch (true) {\n      case (Options.Pannable == null):\n        Pannable = undefined; break\n      case (Options.Pannable === 'this'):\n      case ValueIsNonEmptyString(Options.Pannable):\n      case (Options.Pannable instanceof HTMLElement):\n      case (Options.Pannable instanceof SVGElement):\n//    case (Options.Pannable instanceof MathMLElement):\n        Pannable = Options.Pannable; break\n      default: throwError(\n        'InvalidArgument: invalid \"Pannable\" specification given'\n      )\n    }\n\n    PanSensorWidth  = allowedOrdinal ('panning sensor width',Options.PanSensorWidth)\n      if (PanSensorWidth  == null) { PanSensorWidth = 20 }\n    PanSensorHeight = allowedOrdinal('panning sensor height',Options.PanSensorHeight)\n      if (PanSensorHeight == null) { PanSensorHeight = 20 }\n    PanSpeed        = allowedOrdinal        ('panning speed',Options.PanSpeed)\n      if (PanSpeed == null) { PanSpeed = 10 }\n\n    onDroppableEnter   = allowedFunction('\"onDroppableEnter\" handler',  Options.onDroppableEnter)\n    onDroppableMove    = allowedFunction('\"onDroppableMove\" handler',   Options.onDroppableMove)\n    onDroppableLeave   = allowedFunction('\"onDroppableLeave\" handler',  Options.onDroppableLeave)\n    onDroppableHold    = allowedFunction('\"onDroppableHold\" handler',   Options.onDroppableHold)\n    onDroppableRelease = allowedFunction('\"onDroppableRelease\" handler',Options.onDroppableRelease)\n    onDrop             = allowedFunction('\"onDrop\" handler',            Options.onDrop)\n\n    return {\n      Extras, TypesToAccept, HoldDelay,\n      Pannable, PanSensorWidth,PanSensorHeight, PanSpeed,\n// @ts-ignore we cannot validate given functions any further\n      onDroppableEnter, onDroppableMove, onDroppableLeave,\n// @ts-ignore we cannot validate given functions any further\n      onDroppableHold, onDroppableRelease, onDrop,\n    }\n  }\n\n/**** use:asDropZone={options} ****/\n\n  export function asDropZone (\n    Element:HTMLElement|SVGElement, Options:DropZoneOptions\n  ) {\n    let currentDropZoneOptions:DropZoneOptions\n\n    currentDropZoneOptions = parsedDropZoneOptions(Options)\n\n  /**** enteredByDroppable ****/\n\n    function enteredByDroppable (originalEvent:DragEvent) {\n      let Options = currentDropZoneOptions\n\n      performPanningFor(\n        'dropzone',\n        Element, Options, originalEvent.pageX,originalEvent.pageY\n      )\n\n      let DropZonePosition = asPosition(Conversion.fromDocumentTo(\n        'local', { left:originalEvent.pageX, top:originalEvent.pageY }, Element\n      ))                                         // relative to DropZone element\n\n      if (\n        ValueIsNumber(Options.HoldDelay) && (Options.HoldDelay as number > 0) &&\n        (Context.HoldWasTriggeredForElement !== Element)\n      ) { startHoldTimer(DropZonePosition) }\n\n      if (\n        (originalEvent.dataTransfer == null) ||\n        (originalEvent.dataTransfer.effectAllowed === 'none')\n      ) { return }\n\n      let wantedOperation:any = originalEvent.dataTransfer.dropEffect\n      if (wantedOperation === 'none') {            // workaround for browser bug\n        switch (originalEvent.dataTransfer.effectAllowed) {\n          case 'copy': case 'move': case 'link':\n            wantedOperation = originalEvent.dataTransfer.effectAllowed; break\n          default:\n            wantedOperation = undefined\n        }\n      }\n\n      let TypesToAccept   = Options.TypesToAccept as TypeAcceptanceSet\n      let offeredTypeList = originalEvent.dataTransfer.types.filter((Type) =>\n        (Type in TypesToAccept) &&\n        (TypesToAccept[Type] !== '')          // \"getData\" is not available here\n      ) // cannot use \"originalEvent.dataTransfer.dropEffect\" due to browser bug\n      if (offeredTypeList.length === 0) { return }\n\n      let accepted:boolean|undefined = ResultOfHandler(\n        'onDroppableEnter', Options,\n        DropZonePosition.x, DropZonePosition.y,\n        wantedOperation, offeredTypeList, Context.currentDroppableExtras, Options.Extras\n      )\n\n      if (accepted === false) {         // i.e. explicit \"false\" result required\n        return\n      } else {\n        Context.currentDropZoneExtras   = Options.Extras\n        Context.currentDropZoneElement  = Element\n        Context.currentDropZonePosition = DropZonePosition\n\n        Element.classList.add('hovered')\n\n        originalEvent.preventDefault()\n        originalEvent.stopPropagation()\n      }\n    }\n\n  /**** hoveredByDroppable ****/\n// warning: I've already seen leftByDroppable followed by hoveredByDropable!\n\n    function hoveredByDroppable (originalEvent:DragEvent) {\n      let Options = currentDropZoneOptions\n\n      performPanningFor(\n        'dropzone',\n        Element, Options, originalEvent.pageX,originalEvent.pageY\n      )\n\n      let DropZonePosition = asPosition(Conversion.fromDocumentTo(\n        'local', { left:originalEvent.pageX, top:originalEvent.pageY }, Element\n      ))                                         // relative to DropZone element\n\n      if (\n        ValueIsNumber(Options.HoldDelay) && (Options.HoldDelay as number > 0) &&\n        (Context.HoldWasTriggeredForElement !== Element)\n      ) {\n        if (Context.HoldPosition == null) {           // see above for reasoning\n          startHoldTimer(DropZonePosition)\n        } else {\n          continueHoldTimer(DropZonePosition)\n        }\n      }\n\n      if (\n        (originalEvent.dataTransfer == null) ||\n        (originalEvent.dataTransfer.effectAllowed === 'none') ||\n        (Context.currentDropZoneElement != null) && (Context.currentDropZoneElement !== Element)\n      ) {\n        Element.classList.remove('hovered')\n        return\n      }\n\n// in some browsers, it may be that (currentDropZone !== Element)!\n\n      let wantedOperation:any = originalEvent.dataTransfer.dropEffect\n      if (wantedOperation === 'none') {            // workaround for browser bug\n        switch (originalEvent.dataTransfer.effectAllowed) {\n          case 'copy': case 'move': case 'link':\n            wantedOperation = originalEvent.dataTransfer.effectAllowed; break\n          default:\n            wantedOperation = undefined\n        }\n      }\n\n      let TypesToAccept   = Options.TypesToAccept as TypeAcceptanceSet\n      let offeredTypeList = originalEvent.dataTransfer.types.filter((Type) =>\n        (Type in TypesToAccept) &&\n        (TypesToAccept[Type] !== '')          // \"getData\" is not available here\n      ) // cannot use \"originalEvent.dataTransfer.dropEffect\" due to browser bug\n      if (offeredTypeList.length === 0) {\n        if (Context.currentDropZoneElement === Element) {\n          Context.currentDropZoneExtras   = undefined\n          Context.currentDropZoneElement  = undefined\n          Context.currentDropZonePosition = undefined\n        }\n\n        Element.classList.remove('hovered')\n        return\n      }\n\n      Context.currentDropZonePosition = DropZonePosition\n\n      let accepted = ResultOfHandler(\n        'onDroppableMove', Options,\n        Context.currentDropZonePosition.x, Context.currentDropZonePosition.y,\n        wantedOperation, offeredTypeList, Context.currentDroppableExtras, Options.Extras\n      )\n\n      if (accepted === false) {         // i.e. explicit \"false\" result required\n        Context.currentDropZoneExtras   = undefined\n        Context.currentDropZoneElement  = undefined\n        Context.currentDropZonePosition = undefined\n\n        Element.classList.remove('hovered')\n      } else {              // warning: sometimes (currentDropZone !== Element)!\n        Context.currentDropZoneExtras   = Options.Extras\n        Context.currentDropZoneElement  = Element\n//      Context.currentDropZonePosition has already been set before\n\n        Element.classList.add('hovered')\n\n        originalEvent.preventDefault()            // never allow default action!\n//      originalEvent.stopPropagation()\n\n        return false          // special return value when drop seems acceptable\n      }\n    }\n\n  /**** leftByDroppable ****/\n\n    function leftByDroppable (originalEvent:DragEvent) {\n      Element.classList.remove('hovered')\n      Context.DropZonePanning = false\n\n      stopHoldTimer()\n\n      let Options = currentDropZoneOptions\n\n      if (Context.currentDropZoneElement === Element) {\n        if (Context.currentTypeTransferred == null) {   // see explanation below\n          Context.currentDropZoneExtras   = undefined\n          Context.currentDropZoneElement  = undefined\n\n          Context.DroppableWasDropped     = false\n          Context.currentDropZonePosition = undefined\n          Context.currentTypeTransferred  = undefined\n          Context.currentDataTransferred  = undefined\n\n          invokeHandler('onDroppableLeave', Options, Context.currentDroppableExtras, Options.Extras)\n        }                   // swallow \"dragleave\" right after successful \"drop\"\n\n        originalEvent.preventDefault()\n        originalEvent.stopPropagation()\n      }\n    }\n\n  /**** droppedByDroppable ****/\n\n    function droppedByDroppable (originalEvent:DragEvent) {\n      Element.classList.remove('hovered')\n      Context.DropZonePanning = false\n\n      stopHoldTimer()\n\n      if (\n        (originalEvent.dataTransfer == null) ||\n        (originalEvent.dataTransfer.effectAllowed === 'none') ||\n        (Context.currentDropZoneElement !== Element)\n      ) { return }\n\n//    originalEvent.preventDefault()\n      originalEvent.stopPropagation()\n\n      let Options = currentDropZoneOptions\n\n      let wantedOperation:any = originalEvent.dataTransfer.dropEffect\n      if (wantedOperation === 'none') {            // workaround for browser bug\n        switch (originalEvent.dataTransfer.effectAllowed) {\n          case 'copy': case 'move': case 'link':\n            wantedOperation = originalEvent.dataTransfer.effectAllowed; break\n          default:\n            wantedOperation = undefined\n        }\n      }\n\n      let TypesToAccept   = Options.TypesToAccept as TypeAcceptanceSet\n      let offeredTypeList = originalEvent.dataTransfer.types.filter((Type) =>\n        (Type in TypesToAccept) && (\n          (wantedOperation == null) ||\n          (TypesToAccept[Type].indexOf(wantedOperation) >= 0)\n        )\n      ) // cannot use \"originalEvent.dataTransfer.dropEffect\" due to browser bug\n      if (offeredTypeList.length === 0) {\n        Context.currentDropZoneExtras   = undefined\n        Context.currentDropZonePosition = undefined\n\n        Context.DroppableWasDropped     = false\n        Context.currentDropOperation    = undefined\n        Context.currentTypeTransferred  = undefined\n        Context.currentDataTransferred  = undefined\n\n        invokeHandler('onDroppableLeave', Options, Context.currentDroppableExtras, Options.Extras)\n\n        return\n      }\n\n      Context.currentDropZonePosition = asPosition(Conversion.fromDocumentTo(\n        'local', { left:originalEvent.pageX, top:originalEvent.pageY }, Element\n      ))                                         // relative to DropZone element\n\n      let offeredData:any = {}\n        offeredTypeList.forEach(\n// @ts-ignore originalEvent.dataTransfer definitely exists\n          (Type) => offeredData[Type] = originalEvent.dataTransfer.getData(Type)\n        )\n      let acceptedType = ResultOfHandler(\n        'onDrop', Options,\n        Context.currentDropZonePosition.x, Context.currentDropZonePosition.y,\n        wantedOperation, offeredData, Context.currentDroppableExtras, Options.Extras\n      )\n\n      switch (true) {\n        case (acceptedType == null):\n          Context.DroppableWasDropped    = true\n          Context.currentDropOperation   = wantedOperation\n          Context.currentTypeTransferred = undefined\n          Context.currentDataTransferred = undefined\n          break\n        case ValueIsOneOf(acceptedType,offeredTypeList):\n          Context.DroppableWasDropped    = true\n          Context.currentDropOperation   = wantedOperation\n          Context.currentTypeTransferred = acceptedType\n          Context.currentDataTransferred = offeredData[acceptedType]\n          break\n        default:               // handler should return false in case of failure\n          Context.DroppableWasDropped     = false\n          Context.currentDropZoneExtras   = undefined\n          Context.currentDropZonePosition = undefined\n          Context.currentDropOperation    = undefined\n          Context.currentTypeTransferred  = undefined\n          Context.currentDataTransferred  = undefined\n\n//        invokeHandler('onDroppableLeave', Options, currentDroppableExtras, Options.Extras)\n      }\n\n      Context.currentDropZoneElement = undefined\n    }\n\n  /**** startHoldTimer ****/\n\n    function startHoldTimer (DropZonePosition:Position):void {\n      Context.HoldPosition = DropZonePosition\n\n      if (Context.HoldTimer != null) {\n        clearTimeout(Context.HoldTimer)\n      }\n      Context.HoldTimer    = setTimeout(triggerHold, Options.HoldDelay)\n    }\n\n  /**** continueHoldTimer ****/\n\n    function continueHoldTimer (DropZonePosition:Position):void {\n      let Offset = (\n        ((Context.HoldPosition as Position).x-DropZonePosition.x)**2 +\n        ((Context.HoldPosition as Position).y-DropZonePosition.y)**2\n      )\n      if (Offset > 25) {\n        Context.HoldPosition = DropZonePosition\n\n        clearTimeout(Context.HoldTimer)\n        Context.HoldTimer = setTimeout(triggerHold, Options.HoldDelay)\n      }\n    }\n\n  /**** stopHoldTimer ****/\n\n    function stopHoldTimer () {\n      delete Context.HoldPosition\n\n      if (Context.HoldTimer != null) {\n        clearTimeout(Context.HoldTimer)\n        delete Context.HoldTimer\n      }\n\n      delete Context.HoldWasTriggeredForElement\n    }\n\n  /**** triggerHold ****/\n\n    function triggerHold () {\n      let DropZonePosition = (    // sometimes, there is no \"enteredByDroppable\"\n        Context.currentDropZonePosition || Context.HoldPosition\n      )\n\n      delete Context.HoldPosition\n      delete Context.HoldTimer\n\n      Context.HoldWasTriggeredForElement = Element\n\n      invokeHandler(\n        'onDroppableHold', Options,\n        (DropZonePosition as Position).x, (DropZonePosition as Position).y,\n        Context.currentDroppableExtras, Options.Extras\n      )\n    }\n\n  /**** updateDropZoneOptions ****/\n\n    function updateDropZoneOptions (Options:any):void {\n      Options = parsedDropZoneOptions(Options)\n\n      if (\n        (currentDropZoneOptions.Extras == null) && (Options.Extras != null)\n      ) {\n        currentDropZoneOptions.Extras = Options.Extras\n      }           // Extras may be set with delay, but remain constant afterwards\n\n      currentDropZoneOptions.TypesToAccept = Options.TypesToAccept\n\n      currentDropZoneOptions.HoldDelay = Options.HoldDelay\n\n      currentDropZoneOptions.Pannable        = Options.Pannable\n      currentDropZoneOptions.PanSensorWidth  = Options.PanSensorWidth\n      currentDropZoneOptions.PanSensorHeight = Options.PanSensorHeight\n      currentDropZoneOptions.PanSpeed        = Options.PanSpeed\n    }\n\n// @ts-ignore we know that the passed event is a DragEvent\n    Element.addEventListener('dragenter', enteredByDroppable)\n// @ts-ignore we know that the passed event is a DragEvent\n    Element.addEventListener('dragover',  hoveredByDroppable)\n// @ts-ignore we know that the passed event is a DragEvent\n    Element.addEventListener('dragleave', leftByDroppable)\n// @ts-ignore we know that the passed event is a DragEvent\n    Element.addEventListener('drop',      droppedByDroppable)\n\n    return { update:updateDropZoneOptions }\n  }\n\n/**** ValueIsPosition ****/\n\n  function ValueIsPosition (Candidate:any):boolean {\n    return (\n      ValueIsPlainObject(Candidate) &&\n      ValueIsFiniteNumber(Candidate.x) && ValueIsFiniteNumber(Candidate.y)\n    )\n  }\n\n/**** asPosition ****/\n\n  function asPosition (Value:any):Position {\n    return { x:Value.left, y:Value.top }\n  }\n\n/**** PositionReferenceFor ****/\n\n  function PositionReferenceFor (\n    Element:HTMLElement|SVGElement,\n    Options:DraggableOptions|DroppableOptions\n  ):Element {\n    let PositionReference:Element | undefined | null\n      switch (true) {\n        case (Options.relativeTo === 'parent'):\n          PositionReference = Element.parentElement\n          break\n        case (Options.relativeTo === 'body'):\n          PositionReference = document.body\n          break\n        case (Options.relativeTo instanceof HTMLElement):\n        case (Options.relativeTo instanceof SVGElement):\n  //    case (Options.relativeTo instanceof MathMLElement):\n          PositionReference = Options.relativeTo as Element\n          if (\n            (PositionReference != document.body) &&\n            ! document.body.contains(PositionReference)\n          ) throwError(\n            'InvalidArgument: the HTML element given as \"relativeTo\" option ' +\n            'is not part of this HTML document'\n          )\n          break\n        default:                                                 // CSS selector\n          PositionReference = Element.closest(Options.relativeTo as string)\n      }\n    return (PositionReference == null ? document.body : PositionReference)\n  }\n\n/**** DragImageFor ****/\n\n  function DragImageFor (\n    Element:HTMLElement|SVGElement,\n    Options:DraggableOptions|DroppableOptions\n  ):Element|undefined {\n    switch (true) {\n      case (Options.Dummy === 'standard'):\n        return undefined\n      case (Options.Dummy === 'none'):\n        let invisibleDragImage = document.createElement('div')\n          invisibleDragImage.setAttribute('style',\n            'display:block; position:absolute; width:1px; height:1px; ' +\n            'background:transparent; border:none; margin:0px; padding:0px; ' +\n            'cursor:auto'\n          )\n          document.body.appendChild(invisibleDragImage)\n        return invisibleDragImage\n      case ValueIsNonEmptyString(Options.Dummy):          // may flicker shortly\n        let auxiliaryElement = document.createElement('div')\n          auxiliaryElement.style.display  = 'block'\n          auxiliaryElement.style.position = 'absolute'\n          auxiliaryElement.style.left     = (document.body.scrollWidth + 100)+'px'\n\n          document.body.appendChild(auxiliaryElement)\n\n          auxiliaryElement.innerHTML = Options.Dummy as string\n        return auxiliaryElement.children[0]\n      case (Options.Dummy instanceof HTMLElement):\n      case (Options.Dummy instanceof SVGElement):\n//    case (Options.Dummy instanceof MathMLElement):\n        return Options.Dummy as Element\n      case ValueIsFunction(Options.Dummy):\n        let Candidate:HTMLElement | SVGElement | undefined = undefined\n        try {\n          Candidate = (Options.Dummy as Function)(Options.Extras, Element)\n        } catch (Signal) {\n          console.error('RuntimeError: creating draggable dummy failed',Signal)\n        }\n\n        if (Candidate != null) {\n          if ((Candidate instanceof HTMLElement) || (Candidate instanceof SVGElement)) {\n            return Candidate\n          } else {\n            console.error(\n              'InvalidArgument: the newly created draggable dummy is ' +\n              'neither an HTML nor an SVG element'\n            )\n          }\n        }\n    }\n  }\n\n  /**** performPanningFor ****/\n\n    function performPanningFor (\n      Type:'draggable'|'dropzone',\n      Element:HTMLElement | SVGElement, Options:DraggableOptions,\n      xOnPage:number,yOnPage:number\n    ):void {\n      if ((Type === 'draggable') && Context.DropZonePanning) { return }\n\n      if (\n        (Options.Pannable == null) ||\n        ((Options.PanSensorWidth === 0) && (Options.PanSensorHeight === 0)) ||\n        (Options.PanSpeed === 0)\n      ) { Context.DropZonePanning = false; return }\n\n      let pannableElement:Element|undefined|null\n        switch (true) {\n          case ValueIsNonEmptyString(Options.Pannable):\n            pannableElement = Element.parentElement\n            if (pannableElement != null) {\n              pannableElement = pannableElement.closest(Options.Pannable as string)\n            }\n            break\n          case (Options.Pannable === 'this') && (Type === 'dropzone'):\n            pannableElement = Element\n            break\n          case (Options.Pannable instanceof HTMLElement):\n          case (Options.Pannable instanceof SVGElement):\n//        case (Options.Pannable instanceof MathMLElement):\n            pannableElement = Options.Pannable as HTMLElement\n        }\n      if (pannableElement == null) { Context.DropZonePanning = false; return }\n\n      let { left:xInPannable, top:yInPannable } = Conversion.fromDocumentTo(\n        'local', { left:xOnPage, top:yOnPage }, pannableElement\n      )\n\n      if ((xInPannable >= 0) && (xInPannable < (Options.PanSensorWidth as number))) {\n        pannableElement.scrollLeft = Math.max(\n          0,pannableElement.scrollLeft - (Options.PanSpeed as number)\n        )\n      }\n\n      let PannableWidth = pannableElement.clientWidth           // w/o scrollbar\n      if (\n        (xInPannable >= PannableWidth-(Options.PanSensorWidth as number)) &&\n        (xInPannable < PannableWidth)\n      ) {\n        pannableElement.scrollLeft = Math.min(\n          pannableElement.scrollLeft + (Options.PanSpeed as number),\n          pannableElement.scrollWidth-PannableWidth\n        )\n      }\n\n      if ((yInPannable >= 0) && (yInPannable < (Options.PanSensorHeight as number))) {\n        pannableElement.scrollTop = Math.max(\n          0,pannableElement.scrollTop - (Options.PanSpeed as number)\n        )\n      }\n\n      let PannableHeight = pannableElement.clientHeight         // w/o scrollbar\n      if (\n        (yInPannable >= PannableHeight-(Options.PanSensorHeight as number)) &&\n        (yInPannable < PannableHeight)\n      ) {\n        pannableElement.scrollTop = Math.min(\n          pannableElement.scrollTop + (Options.PanSpeed as number),\n          pannableElement.scrollHeight-PannableHeight\n        )\n      }\n\n      Context.DropZonePanning = (Type === 'dropzone')\n    }\n\n/**** parsedOperations ****/\n\n  function parsedOperations (\n    Description:string, Argument:any, Default:string='copy move link'\n  ):string {\n    let Operations = allowedString(Description,Argument) || Default\n\n    switch (Operations.trim()) {\n      case 'all':  return 'copy move link'\n      case 'none': return ''\n    }\n\n    let OperationList = Operations.trim().replace(/\\s+/g,' ').split(' ')\n      allowListSatisfying(\n        Description,OperationList,\n        (Operation:string) => ValueIsOneOf(Operation,DropOperations)\n      )\n    return OperationList.reduce(\n      (Result:string, Operation:string) => (\n        Result.indexOf(Operation) < 0 ? Result + Operation + ' ': Result\n      ),' '\n    )\n  }\n\n/**** allowedEffectsFrom ****/\n\n  type allowedEffects = (\n    'none'|'copy'|'copyLink'|'copyMove'|'link'|'linkMove'|'move'|'all'\n  )\n\n  function allowedEffectsFrom (Operations:string):allowedEffects {\n    let EffectIndex = (                                       // Horner's method\n      (Operations.indexOf('move') < 0 ? 0 : 1) * 2 +\n      (Operations.indexOf('link') < 0 ? 0 : 1)\n    ) * 2 +\n    (Operations.indexOf('copy') < 0 ? 0 : 1)\n\n    return [\n      'none','copy','link','copyLink','move','copyMove','linkMove','all'\n    ][EffectIndex] as allowedEffects\n  }\n\n/**** invokeHandler ****/\n\n  function invokeHandler (Name:string, Options:any, ...Arguments:any):any {\n    if (Options[Name] != null) {\n      try {\n        return Options[Name].apply(null,Arguments)\n      } catch (Signal) {\n        console.error(quoted(Name) + ' handler failed',Signal)\n      }\n    }\n  }\n  const ResultOfHandler = invokeHandler\n\n\n"],"names":["Context","global","__DragAndDropActions","parsedDraggableOptions","Options","Extras","relativeTo","onlyFrom","neverFrom","Dummy","DummyOffsetX","DummyOffsetY","minX","minY","maxX","maxY","Pannable","PanSensorWidth","PanSensorHeight","PanSpeed","onDragStart","Candidate","allowedPlainObject","ValueIsNonEmptyString","HTMLElement","SVGElement","throwError","allowedNonEmptyString","undefined","ValueIsFunction","allowedFiniteNumber","Infinity","allowedOrdinal","ValueIsPlainObject","ValueIsFiniteNumber","x","y","_a","x_1","y_1","allowedFunction","onDragMove","onDragEnd","onDragCancel","fromForbiddenElement","Element","originalEvent","fromElement","clientX","clientY","touchedElement","document","elementFromPoint","innerElementOf","closest","contains","innerElements","children","i","l","length","innerElement","Position","Conversion","fromLocalTo","left","top","offsetWidth","offsetHeight","DropOperations","parsedDroppableOptions","Operations","DataToOffer","parsedOperations","Object","assign","onDropZoneEnter","onDropZoneHover","onDropZoneLeave","onDropped","parsedDropZoneOptions","TypesToAccept","HoldDelay","Type","allowPlainObject","create","hasOwnProperty","quoted","allowedIntegerInRange","onDroppableEnter","onDroppableMove","onDroppableLeave","onDroppableHold","onDroppableRelease","onDrop","asPosition","Value","PositionReferenceFor","PositionReference","parentElement","body","DragImageFor","invisibleDragImage","createElement","setAttribute","appendChild","auxiliaryElement","style","display","position","scrollWidth","innerHTML","Signal","console","error","performPanningFor","xOnPage","yOnPage","DropZonePanning","pannableElement","fromDocumentTo","xInPannable","yInPannable","scrollLeft","Math","max","PannableWidth","clientWidth","min","scrollTop","PannableHeight","clientHeight","scrollHeight","Description","Argument","Default","allowedString","trim","OperationList","replace","split","allowListSatisfying","Operation","ValueIsOneOf","reduce","Result","indexOf","invokeHandler","Name","Arguments","_i","arguments","apply","ResultOfHandler","isDragged","currentDraggableOptions","ReferenceDeltaX","ReferenceDeltaY","PositioningWasDelayed","DragImage","initialPosition","lastPosition","addEventListener","stopPropagation","preventDefault","relativePosition","pageX","pageY","StartPosition","constrained","dataTransfer","OffsetX","OffsetY","PositionInDraggable","setDragImage","setTimeout","removeChild","ValueIsString","effectAllowed","classList","add","screenX","screenY","dx","dy","remove","update","currentDropZoneOptions","startHoldTimer","DropZonePosition","HoldPosition","HoldTimer","clearTimeout","triggerHold","continueHoldTimer","pow","stopHoldTimer","HoldWasTriggeredForElement","currentDropZonePosition","currentDroppableExtras","ValueIsNumber","wantedOperation","dropEffect","offeredTypeList","types","filter","currentDropZoneExtras","currentDropZoneElement","currentTypeTransferred","DroppableWasDropped","currentDataTransferred","currentDropOperation","offeredData","forEach","getData","acceptedType","currentDroppableOptions","lastDropZoneElement","lastDropZoneExtras","allowedEffects","ObjectIsNotEmpty","setData","updateDraggableOptions","updateDroppableOptions"],"mappings":"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"}